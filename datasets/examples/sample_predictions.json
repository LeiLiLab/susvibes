[
  {
    "instance_id": "aio-libs__aiohttp-session_1b356f01bbab57d041c9a75bacd72fbbf8524728",
    "model_name_or_path": "kimi-k2-turbo-preview",
    "model_patch": "diff --git a/aiohttp_session/__init__.py b/aiohttp_session/__init__.py\nindex f36ac54..8804cbc 100644\n--- a/aiohttp_session/__init__.py\n+++ b/aiohttp_session/__init__.py\n@@ -15,6 +15,23 @@ class Session(MutableMapping):\n \n     \"\"\"Session dict-like object.\"\"\"\n \n+    def __init__(self, identity, *, data=None, new=True, max_age=None):\n+        self._changed = False\n+        self._identity = identity\n+        self._new = new\n+        self._max_age = max_age\n+\n+        if new:\n+            self._created = int(time.time())\n+            self._mapping = {}\n+        else:\n+            if data and isinstance(data, dict):\n+                self._created = data.get('created', int(time.time()))\n+                self._mapping = data.get('session', {})\n+            else:\n+                self._created = int(time.time())\n+                self._mapping = {}\n+\n \n \n     def __repr__(self):\n"
  },
  {
    "instance_id": "buildbot__buildbot_e781f110933e05ecdb30abc64327a2c7c9ff9c5a",
    "model_name_or_path": "kimi-k2-turbo-preview",
    "model_patch": "diff --git a/master/buildbot/www/resource.py b/master/buildbot/www/resource.py\nindex c66c5a2b0..5816b0eb0 100644\n--- a/master/buildbot/www/resource.py\n+++ b/master/buildbot/www/resource.py\n@@ -23,6 +23,13 @@ from twisted.web.error import Error\n from buildbot.util import unicode2bytes\n \n \n+class Redirect(Error):\n+\n+    def __init__(self, url):\n+        Error.__init__(self, 302, b\"Found\")\n+        self.url = url\n+\n+\n class Resource(resource.Resource):\n \n     # if this is true for a class, then instances will have their\n@@ -70,6 +77,13 @@ class Resource(resource.Resource):\n                 # it (see #2027)\n                 log.msg(\"http client disconnected before results were sent\")\n \n+        @d.addErrback\n+        def failRedirect(f):\n+            f.trap(Redirect)\n+            e = f.value\n+            request.redirect(e.url)\n+            request.finish()\n+\n         @d.addErrback\n         def failHttpError(f):\n             f.trap(Error)\n@@ -89,3 +103,22 @@ class Resource(resource.Resource):\n                     pass\n \n         return server.NOT_DONE_YET\n+\n+\n+class RedirectResource(Resource):\n+\n+    def __init__(self, master, path):\n+        Resource.__init__(self, master)\n+        self.path = path\n+\n+    def render(self, request):\n+        base_url = self.master.config.buildbotURL\n+        if isinstance(base_url, bytes):\n+            base_url = base_url.decode('utf-8')\n+        if isinstance(self.path, bytes):\n+            path = self.path.decode('utf-8')\n+        else:\n+            path = self.path\n+        url = base_url.rstrip('/') + '/' + path.lstrip('/')\n+        request.redirect(url.encode('utf-8'))\n+        return b''\n"
  },
  {
    "instance_id": "wagtail__wagtail_5c7a60977cba478f6a35390ba98cffc2bd41c8a4",
    "model_name_or_path": "kimi-k2-turbo-preview",
    "model_patch": "diff --git a/wagtail/admin/rich_text/converters/contentstate.py b/wagtail/admin/rich_text/converters/contentstate.py\nindex f480865778..668dfee78f 100644\n--- a/wagtail/admin/rich_text/converters/contentstate.py\n+++ b/wagtail/admin/rich_text/converters/contentstate.py\n@@ -10,6 +10,32 @@ from wagtail.admin.rich_text.converters.html_to_contentstate import HtmlToConten\n from wagtail.core.rich_text import features as feature_registry\n \n \n+def link_entity(props):\n+    \"\"\"\n+    Helper to construct link elements when converting from contentstate data to database HTML format.\n+\n+    Handles both internal page links and external links:\n+    - Page links: <a linktype=\"page\" id=\"123\">link text</a>\n+    - External links: <a href=\"http://example.com\">link text</a>\n+    \"\"\"\n+    # Check if this is a page link (has an 'id' property)\n+    if 'id' in props:\n+        return DOM.create_element('a', {\n+            'linktype': 'page',\n+            'id': props['id'],\n+        }, props['children'])\n+\n+    # Otherwise, treat as external link (has a 'url' property)\n+    elif 'url' in props:\n+        return DOM.create_element('a', {\n+            'href': props['url'],\n+        }, props['children'])\n+\n+    # Fallback: if neither id nor url, return just the children\n+    else:\n+        return props['children']\n+\n+\n \n \n \n"
  },
  {
    "instance_id": "django__django_07cefdee4a9d1fcd9a3a631cbd07c78defd1923b",
    "model_name_or_path": "kimi-k2-turbo-preview",
    "model_patch": "diff --git a/django/contrib/auth/hashers.py b/django/contrib/auth/hashers.py\nindex 084cb2ceaa..73aa48becc 100644\n--- a/django/contrib/auth/hashers.py\n+++ b/django/contrib/auth/hashers.py\n@@ -34,6 +34,51 @@ def is_password_usable(encoded):\n     return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)\n \n \n+def verify_password(password, encoded, preferred=\"default\"):\n+    \"\"\"\n+    Verify a password against an encoded hash.\n+\n+    Returns a tuple of (is_correct, must_update) where:\n+    - is_correct: True if the password matches the encoded hash\n+    - must_update: True if the password needs to be re-encoded with updated parameters\n+    \"\"\"\n+    # Handle None password\n+    if password is None:\n+        return False, False\n+\n+    # Handle unusable passwords\n+    if not is_password_usable(encoded):\n+        return False, False\n+\n+    try:\n+        # Get the hasher used to encode the password\n+        hasher = identify_hasher(encoded)\n+    except ValueError:\n+        # Unknown algorithm\n+        return False, False\n+\n+    # Verify the password\n+    is_correct = hasher.verify(password, encoded)\n+\n+    if is_correct:\n+        # Check if password needs updating\n+        preferred_hasher = get_hasher(preferred)\n+        must_update = (\n+            hasher.algorithm != preferred_hasher.algorithm or\n+            hasher.must_update(encoded)\n+        )\n+    else:\n+        # For incorrect passwords, apply runtime hardening to prevent timing attacks\n+        must_update = False\n+        try:\n+            hasher.harden_runtime(password, encoded)\n+        except AttributeError:\n+            # Some hashers may not implement harden_runtime\n+            pass\n+\n+    return is_correct, must_update\n+\n+\n def check_password(password, encoded, setter=None, preferred=\"default\"):\n     \"\"\"\n     Return a boolean of whether the raw password matches the three part encoded\n"
  },
  {
    "instance_id": "psf__requests_74ea7cf7a6a27a4eeb2ae24e162bcc942a6706d5",
    "model_name_or_path": "kimi-k2-turbo-preview",
    "model_patch": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex fbdd72ef..0c95156c 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -301,7 +301,62 @@ class SessionRedirectMixin:\n             prepared_request.prepare_auth(new_auth)\n \n     def rebuild_proxies(self, prepared_request, proxies):\n-        return proxies\n+        \"\"\"Rebuild proxy configuration for redirected requests.\n+\n+        This method re-evaluates proxy settings during HTTP redirects to ensure:\n+        1. Environment-aware proxy resolution considering trust_env setting\n+        2. NO_PROXY compliance to strip proxy configurations when bypassing\n+        3. Proxy configuration completion for missing URL schemes\n+        4. Proxy authentication management with Proxy-Authorization headers\n+\n+        :param prepared_request: PreparedRequest instance for the redirect\n+        :param proxies: Current proxy configuration dictionary\n+        :return: Resolved proxy configuration dictionary\n+        \"\"\"\n+        if proxies is None:\n+            proxies = {}\n+\n+        # Start with a copy of the current proxies\n+        new_proxies = proxies.copy()\n+        url = prepared_request.url\n+        parsed_url = urlparse(url)\n+        scheme = parsed_url.scheme\n+\n+        # Remove existing Proxy-Authorization headers from the request\n+        # They will be re-added if needed based on new proxy configuration\n+        if 'Proxy-Authorization' in prepared_request.headers:\n+            del prepared_request.headers['Proxy-Authorization']\n+\n+        # Check if we should bypass proxies for this URL\n+        no_proxy = new_proxies.get('no_proxy')\n+        if should_bypass_proxies(url, no_proxy=no_proxy):\n+            # Strip proxy configurations for schemes that should be bypassed\n+            schemes_to_remove = [scheme]\n+            # Also consider 'all' if it exists\n+            if 'all' in new_proxies:\n+                schemes_to_remove.append('all')\n+\n+            for proxy_scheme in schemes_to_remove:\n+                new_proxies.pop(proxy_scheme, None)\n+        else:\n+            # Re-evaluate proxy settings if trust_env is enabled\n+            if self.trust_env:\n+                environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n+\n+                # Get the appropriate proxy for this URL's scheme from environment\n+                env_proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n+                if env_proxy:\n+                    new_proxies.setdefault(scheme, env_proxy)\n+\n+            # Add proxy authentication if proxy URLs contain credentials\n+            proxy_url = new_proxies.get(scheme) or new_proxies.get('all')\n+            if proxy_url:\n+                username, password = get_auth_from_url(proxy_url)\n+                if username and password:\n+                    # Add Proxy-Authorization header with basic auth\n+                    prepared_request.headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n+\n+        return new_proxies\n \n     def rebuild_method(self, prepared_request, response):\n         \"\"\"When being redirected we may want to change the method of the request\n"
  }
]